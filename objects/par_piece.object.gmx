<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>color = COLOR.gold; //Set a default color
color_sign = -(color*2 - 1); //This needs to be changed when color is changed
image_speed = 0;

selected = false;
unselect = false; //If it's already selected when clicking, unselect
dragging = false;
dragx = 0;
dragy = 0;

//This is the index of the piece in the board ds_grid
gridx = -1;
gridy = -1;

//This will be an array of valid moves when the piece is picked up
valid_moves = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//We don't need anything in here, we just want it to count down on its own
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(dragging)
{
    x = mouse_x + dragx;
    y = mouse_y + dragy;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_index = color;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var calcx, calcy, moved;

if(dragging)
{
    dragging = false;
    dragx = 0;
    dragy = 0;
    
    //If the alarm hasn't gone off, it was a quick click, not a long drag
    if(alarm[0] &gt; 0)
    {
        alarm[0] = -1;
        //Make sure piece is back where it started
        scr_set_position(id, gridx, gridy);
        //It was tap selected before this press, so unselect
        if(unselect)
        {
            selected = false;
            unselect = false;
            //Change the depth back after releasing
            depth = -10;
        }
    }
    else
    {
        //This is the x and y index calculated for the proposed landing spot
        calcx = round(((x - obj_board.board_offset) / obj_board.board_size));
        calcy = round(((y - obj_board.board_offset) / obj_board.board_size));
        scr_try_move(id, calcx, calcy, valid_moves);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var calcx, calcy;

if(obj_board.status == STATUS.play)
{
    if(collision_point(mouse_x, mouse_y, id, false, false))
    {
        /* DEBUG
        if(keyboard_check(vk_shift))
        {
            global.board[# gridx, gridy] = noone;
            instance_destroy();
            exit;
        }
        */
        
        //If it was already selected, set this so we can remove the selection on release
        unselect = selected;
        
        if(color == global.player_turn)
        {
            selected = true;
            dragging = true;
            alarm[0] = room_speed/4;
            dragx = x - mouse_x;
            dragy = y - mouse_y;
            
            //Change the depth so it's above all the other pieces
            depth = -100;
            
            //Determine valid moves so we know where we can move
            valid_moves = scr_valid_moves(id);
        }
    }
    else if(selected)
    {
        calcx = floor(((mouse_x - obj_board.board_offset) / obj_board.board_size));
        calcy = floor(((mouse_y - obj_board.board_offset) / obj_board.board_size));
        scr_try_move(id, calcx, calcy, valid_moves);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This is the "End turn" event when a piece moves

//Determine if this move put the opponent's king in check
global.check = scr_move_is_check(id, 0, 0);
if(scr_is_stale())
{
    //If no legal moves and king in check, it's a checkmate
    if(global.check)
        obj_board.status = STATUS.checkmate;
    else
        obj_board.status = STATUS.stalemate;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Set the depth of the active player's pieces to be above others
if(color == global.player_turn)
    depth = -10;
else
    depth = 10;

//Only if the turn is actually ended do we check the state of the board
if(obj_board.status != STATUS.promote)
    event_user(2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var x1, x2, y1, y2, valid_count;
valid_count = 0;
if(selected)
{
    draw_set_color(c_yellow);
    draw_set_alpha(0.5);
    for(var yy = 0; yy &lt; 8; yy++)
    {
        for(var xx = 0; xx &lt; 8; xx++)
        {
            if(valid_moves[xx, yy] == 1)
            {
                x1 = obj_board.board_offset + xx*obj_board.board_size;
                x2 = obj_board.board_offset + (xx+1)*obj_board.board_size;
                y1 = obj_board.board_offset + yy*obj_board.board_size;
                y2 = obj_board.board_offset + (yy+1)*obj_board.board_size;
                draw_rectangle(x1, y1, x2, y2, false);
                valid_count++;
            }
        }
    }
}
draw_self();

//Draw this after self so that the X is on top
if(selected &amp;&amp; valid_count == 0)
{
    draw_set_alpha(1);
    draw_sprite(spr_x, 0, x, y);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
